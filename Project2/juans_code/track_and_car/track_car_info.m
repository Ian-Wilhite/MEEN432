function [scenario, egoVehicle] = track_car_info()
% track_car_info Create a drivingScenario that matches the starter oval track.
% It prefers the path generated by gentrack.m (if it exists in the base
% workspace). Otherwise it recreates the same 900 m x 200 m radius oval.

scenario = drivingScenario;

% Pull path from base workspace if available
if evalin('base','exist(''path'',''var'')')
    p = evalin('base','path');
    roadCenters = [p.xpath(:), p.ypath(:), zeros(numel(p.xpath),1)];
    laneWidth = p.width;
else
    % Fallback: regenerate a coarse version of the starter path
    laneWidth = 15;
    radius = 200;
    l_st = 900;
    delta_s = 10;
    total_length = 2*l_st + 2*pi*radius;
    npts = round(total_length/delta_s);
    s = linspace(0,total_length,npts);
    roadCenters = zeros(npts,3);
    for i = 1:npts
        si = s(i);
        if si <= l_st
            roadCenters(i,1:2) = [si, 0];
        elseif si <= l_st + pi*radius
            th = (si - l_st)/radius;
            roadCenters(i,1:2) = [l_st + radius*sin(th), radius*(1-cos(th))];
        elseif si <= 2*l_st + pi*radius
            roadCenters(i,1:2) = [l_st - (si - (l_st + pi*radius)), 2*radius];
        else
            th = (si - (2*l_st + pi*radius))/radius;
            roadCenters(i,1:2) = [-radius*sin(th), 2*radius - radius*(1-cos(th))];
        end
    end
end

laneSpecification = lanespec(1, 'Width', laneWidth);
road(scenario, roadCenters, 'Lanes', laneSpecification, 'Name', 'Road');

% Ego vehicle placed at the first waypoint, heading along the path
egoVehicle = vehicle(scenario, ...
    'ClassID', 1, ...
    'Position', roadCenters(1,:), ...
    'Mesh', driving.scenario.carMesh, ...
    'Name', 'Car');

% Build waypoints/yaw/speed vectors from the road centers
wp = roadCenters;
heading = atan2(diff(wp(:,2)), diff(wp(:,1)));
heading = [heading; heading(end)]; %#ok<AGROW>
speed = ones(size(wp,1),1)*30; % m/s constant speed placeholder

trajectory(egoVehicle, wp, speed, 'Yaw', heading);

